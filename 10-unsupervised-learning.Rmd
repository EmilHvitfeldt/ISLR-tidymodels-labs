# Unsupervised Learning

This final chapter talks about unsupervised learning. This is broken into two parts. Dimensionality reduction and clustering. One downside at this moment is that clustering is not well integrated into tidymodels at this time. But we are still able to use some of the features in tidymodels.

```{r}
library(tidymodels)
library(tidyverse)
library(magrittr)
library(factoextra)
library(patchwork)
library(proxy)
```

## Principal Components Analysis

```{r}
usarrests <- as_tibble(USArrests, rownames = "state")
glimpse(usarrests)
```

```{r}
# scale before applyig PCA
set.seed(1)
pca_recipe <- recipe(~., data = usarrests) %>%
  step_scale(all_numeric()) %>%
  step_pca(all_numeric(), id = "pca") %>%
  prep()

usarrests %>%
  column_to_rownames("state") %>%
  prcomp(scale = TRUE) %>%
  fviz_pca_biplot(title = "Biplot PCA on usarrests")

# loadings
tidy(pca_recipe, type = "coef", id = "pca")

tidy(pca_recipe, type = "coef", id = "pca") %>%
  pivot_wider(
    id_cols = "terms",
    names_from = "component",
    values_from = "value"
  )

# variance
tidy(pca_recipe, type = "variance", id = "pca")

tidy(pca_recipe, type = "variance", id = "pca") %>%
  pivot_wider(
    id_cols = "terms",
    names_from = "component",
    names_prefix = "PC_",
    values_from = "value"
  )
# cumulative varianvce plot
tidy(pca_recipe, type = "variance", id = "pca") %>%
  filter(terms == "cumulative variance") %>%
  ggplot(aes(component, value)) +
  geom_point() +
  geom_line() +
  ylim(c(0, 100)) +
  ylab("Cumulative variance")
```


```{r}
# on the direct PCA object
usarrests_pca <- usarrests %>%
  select(-state) %>%
  prcomp(scale = TRUE)

tidy(usarrests_pca)
augment(usarrests_pca)
```

## Kmeans Clustering

The `kmeans()` function can be used to perform K-means clustering in R. But before we get to that let us create a synthetic data set that we know has groups.

```{r}
set.seed(2)

x_df <- tibble(
  V1 = rnorm(n = 50, mean = rep(c(0, 3), each = 25)),
  V2 = rnorm(n = 50, mean = rep(c(0, -4), each = 25))
)
```

And we can plot it with ggplot2 to see that the groups are really there. Note that we didn't include this grouping information in `x_df` as we are trying to emulate a situation where we don't know of the possible underlying clusters.

```{r}
x_df %>%
  ggplot(aes(V1, V2, color = rep(c("A", "B"), each = 25))) +
  geom_point()
```

the `kmeans()` functions takes a matrix or data.frame and `centers` which is the number of clusters we want `kmeans()` to find. We also set `nstart = 20`, this allows the algorithm to have multiple initial starting positions, which we use in the hope of finding global maxima instead of local maxima.

```{r}
set.seed(1234)
res_kmeans <- kmeans(x_df, centers = 3, nstart = 20)
```

This fitted model has a lot of different kinds of information.

```{r}
res_kmeans
```

And we can use [broom](https://broom.tidymodels.org/) functions to extract information in tidy formats. The `tidy()` function returns information for each cluster, including their position, size and within-cluster sum-of-squares.

```{r}
tidy(res_kmeans)
```

The `glance()` function returns model wise metrics. One of these is `tot.withinss` which is the total within-cluster sum-of-squares that we seek to minimize when we perform K-means clustering.

```{r}
glance(res_kmeans)
```

Lastly, we can see what cluster each observation belongs to by using `augment()` which "predict" which cluster a given observation belongs to.

```{r}
augment(res_kmeans, data = x_df)
```

we can visualize the result of `augment()` to see how well the clustering performed.

```{r}
augment(res_kmeans, data = x_df) %>%
  ggplot(aes(V1, V2, color = .cluster)) +
  geom_point()
```

This is all well and good, but it would be nice if we could try out a number of different clusters and then find the best one. We will use the `mutate()` and `map()` combo to fit multiple models and extract information from them. We remember to set a seed to ensure reproducibility.

```{r}
set.seed(1234)
multi_kmeans <- tibble(k = 1:10) %>%
  mutate(
    model = purrr::map(k, ~ kmeans(x_df, centers = .x, nstart = 20)),
    tot.withinss = purrr::map_dbl(model, ~ glance(.x)$tot.withinss)
  )

multi_kmeans
```

Now that we have the total within-cluster sum-of-squares we can plot them against `k` so we can use the [elbow method](https://en.wikipedia.org/wiki/Elbow_method_(clustering)) to find the optimal number of clusters.

```{r}
multi_kmeans %>%
  ggplot(aes(k, tot.withinss)) +
  geom_point() +
  geom_line()
```

We see an elbow at `k = 2` which makes us happy since the data set is specifically created to have 2 clusters. We can now extract the model where `k = 2` from `multi_kmeans`.

```{r}
final_kmeans <- multi_kmeans %>%
  filter(k == 2) %>%
  pull(model) %>%
  pluck(1)
```

And we can finish by visualizing the clusters it found.

```{r}
augment(final_kmeans, data = x_df) %>%
  ggplot(aes(V1, V2, color = .cluster)) +
  geom_point()
```

## Hierarchical Clustering

The `hclust()` function is one way to perform hierarchical clustering in R. It only needs one input and that is a dissimilarity structure as produced by `dist()`. Furthermore, we can specify a couple of things, including the agglomeration method. Let us cluster this data in a couple of different ways to see how the choice of agglomeration method changes the clustering. 

```{r}
res_hclust_complete <- x_df %>%
  dist() %>%
  hclust(method = "complete")

res_hclust_average <- x_df %>%
  dist() %>%
  hclust(method = "average")

res_hclust_single <- x_df %>%
  dist() %>%
  hclust(method = "single")
```

the [factoextra](https://rpkgs.datanovia.com/factoextra/index.html) provides functions (`fviz_dend()`) to visualize the clustering created using `hclust()`. We use `fviz_dend()` to show the dendrogram.

```{r}
fviz_dend(res_hclust_complete, main = "complete", k = 2)
fviz_dend(res_hclust_average, main = "average", k = 2)
fviz_dend(res_hclust_single, main = "single", k = 2)
```

If we don't know the importance of the different predictors in data set it could be beneficial to scale the data such that each variable has the same influence. We can perform scaling by using `scale()` before `dist()`.

```{r}
x_df %>%
  scale() %>%
  dist() %>%
  hclust(method = "complete") %>%
  fviz_dend(k = 2)
```
Another way of calculating distances is based on correlation. This only makes sense if has 3 or more variables.

```{r}
# correlation based distance
set.seed(2)
x <- matrix(rnorm(30 * 3), ncol = 3)

x %>%
  proxy::dist(method = "correlation") %>%
  hclust(method = "complete") %>%
  fviz_dend()
```

## PCA on the NCI60 Data

```{r}
data(NCI60, package = "ISLR")
nci60 <- NCI60$data %>%
  as_tibble() %>%
  set_colnames(., paste0("V_", 1:ncol(.))) %>%
  mutate(label = factor(NCI60$labs)) %>%
  relocate(label)

nci60 %>%
  count(label, sort = TRUE)

nci60_pca <- prcomp(nci60 %>% select(-label), scale = TRUE)
tidy(nci60_pca)
augment(nci60_pca)

pc_first_three <- augment(nci60_pca) %>%
  select(c(.fittedPC1, .fittedPC2, .fittedPC3)) %>%
  mutate(label = factor(NCI60$labs))

wrap_plots(
  pc_first_three %>%
    ggplot(aes(.fittedPC1, .fittedPC2, color = label)) +
    geom_point(size = 5, alpha = 0.5) +
    scale_color_discrete(guide = FALSE),
  pc_first_three %>%
    ggplot(aes(.fittedPC1, .fittedPC3, color = label)) +
    geom_point(size = 5, alpha = 0.5)
)

summary(nci60_pca)$importance %>%
  t() %>%
  as_tibble(.name_repair = "universal") %>%
  rowid_to_column() %>%
  select(-Standard.deviation) %>%
  pivot_longer(cols = -rowid) %>%
  ggplot(aes(rowid, value)) +
  geom_point() +
  geom_line() +
  facet_wrap(name ~ ., scales = "free") +
  xlab("Principal Component")
```

## Clustering on nci60 dataset

Let us now see what happens if we perform clustering on the `nci60` data set. Before we start it would be good if we create a scaled version of this data set. We can use the recipes package to perform those transformations. 

```{r}
nci60_scaled <- recipe(~ ., data = nci60) %>%
  step_rm(label) %>%
  step_normalize(all_predictors()) %>%
  prep() %>%
  bake(new_data = NULL)
```

Now we start by fitting multiple hierarchical clustering models using different agglomeration methods.

```{r}
nci60_complete <- nci60_scaled %>%
    dist() %>%
    hclust(method = "complete")

nci60_average <- nci60_scaled %>%
    dist() %>%
    hclust(method = "average")

nci60_single <- nci60_scaled %>%
    dist() %>%
    hclust(method = "single")
```

We then visualize them to see if any of them have some good natural separations.

```{r}
fviz_dend(nci60_complete, main = "Complete")
fviz_dend(nci60_average, main = "Average")
fviz_dend(nci60_single, main = "Single")
```

We now color according to `k = 4` and we get the following separations.

```{r}
nci60_complete %>%
  fviz_dend(k = 4, main = "hclust(complete) on nci60")
```

We now take the clustering id extracted with `cutree` and calculate which Label is the most common within each cluster.

```{r}
tibble(
  label = nci60$label,
  cluster_id = cutree(nci60_complete, k = 4)
) %>%
  count(label, cluster_id) %>%
  group_by(cluster_id) %>%
  mutate(prop = n / sum(n)) %>%
  slice_max(n = 1, order_by = prop) %>%
  ungroup()
```

We can also see what happens if we try to fit a K-means clustering. We liked 4 clusters from earlier so let's stick with that.

```{r}
set.seed(2)
res_kmeans_scaled <- kmeans(nci60_scaled, centers = 4, nstart = 50)
```

We can again use `tidy()` to extract cluster information, note that we only look at `cluster`, `size`, and `withinss` as there are thousands of other variables denoting the location of the cluster.

```{r}
tidy(res_kmeans_scaled) %>%
  select(cluster, size, withinss)
```

lastly, let us see how the two different methods we used compare against each other. Let us save the cluster ids in `cluster_kmeans` and `cluster_hclust` and then use `conf_mat()` in a different way to quickly generate a heatmap between the two methods.

```{r}
cluster_kmeans <- res_kmeans_scaled$cluster
cluster_hclust <- cutree(nci60_complete, k = 4)

tibble(
  kmeans = factor(cluster_kmeans),
  hclust = factor(cluster_hclust)
) %>%
  conf_mat(kmeans, hclust) %>%
  autoplot(type = "heatmap")
```

There is not a lot of agreement between labels which makes sense, since the labels themselves are arbitrarily added. What is important is that they tend to agree quite a lot (the confusion matrix is sparse).

One last thing that is sometimes useful is to perform dimensionality reduction before using the clustering method. Let us use the recipes package to calculate the PCA of `nci60` and keep the 5 first components. (we could have started with `nci60` too if we added `step_rm()` and `step_normalize()`).

```{r}
nci60_pca <- recipe(~., nci60_scaled) %>%
  step_pca(all_predictors(), num_comp = 5) %>%
  prep() %>%
  bake(new_data = NULL)
```

We can now use `hclust()` on this reduced data set, and sometimes we get quite good results since the clustering method doesn't have to work in high dimensions.

```{r}
nci60_pca %>%
  dist() %>%
  hclust() %>%
  fviz_dend(k = 4, main = "hclust on first five PCs")
```
